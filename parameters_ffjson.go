// DO NOT EDIT!
// Code generated by ffjson <https://github.com/pquerna/ffjson>
// source: parameters.go
// DO NOT EDIT!

package main

import (
	"bytes"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

func (mj *FullParameters) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *FullParameters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"NetworkMacs":`)
	/* Falling back. type=map[string]map[string]bool kind=map */
	err = buf.Encode(mj.NetworkMacs)
	if err != nil {
		return err
	}
	buf.WriteString(`,"NetworkLocs":`)
	/* Falling back. type=map[string]map[string]bool kind=map */
	err = buf.Encode(mj.NetworkLocs)
	if err != nil {
		return err
	}
	if mj.MacVariability == nil {
		buf.WriteString(`,"MacVariability":null`)
	} else {
		buf.WriteString(`,"MacVariability":{ `)
		for key, value := range mj.MacVariability {
			fflib.WriteJsonString(buf, key)
			buf.WriteString(`:`)
			fflib.AppendFloat(buf, float64(value), 'g', -1, 32)
			buf.WriteByte(',')
		}
		buf.Rewind(1)
		buf.WriteByte('}')
	}
	if mj.MacCount == nil {
		buf.WriteString(`,"MacCount":null`)
	} else {
		buf.WriteString(`,"MacCount":{ `)
		for key, value := range mj.MacCount {
			fflib.WriteJsonString(buf, key)
			buf.WriteString(`:`)
			fflib.FormatBits2(buf, uint64(value), 10, value < 0)
			buf.WriteByte(',')
		}
		buf.Rewind(1)
		buf.WriteByte('}')
	}
	buf.WriteString(`,"MacCountByLoc":`)
	/* Falling back. type=map[string]map[string]int kind=map */
	err = buf.Encode(mj.MacCountByLoc)
	if err != nil {
		return err
	}
	buf.WriteString(`,"UniqueLocs":`)
	if mj.UniqueLocs != nil {
		buf.WriteString(`[`)
		for i, v := range mj.UniqueLocs {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"UniqueMacs":`)
	if mj.UniqueMacs != nil {
		buf.WriteString(`[`)
		for i, v := range mj.UniqueMacs {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Priors":`)
	/* Falling back. type=map[string]gofind.PriorParameters kind=map */
	err = buf.Encode(mj.Priors)
	if err != nil {
		return err
	}
	buf.WriteString(`,"Results":`)
	/* Falling back. type=map[string]gofind.ResultsParameters kind=map */
	err = buf.Encode(mj.Results)
	if err != nil {
		return err
	}
	if mj.Loaded {
		buf.WriteString(`,"Loaded":true`)
	} else {
		buf.WriteString(`,"Loaded":false`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_FullParametersbase = iota
	ffj_t_FullParametersno_such_key

	ffj_t_FullParameters_NetworkMacs

	ffj_t_FullParameters_NetworkLocs

	ffj_t_FullParameters_MacVariability

	ffj_t_FullParameters_MacCount

	ffj_t_FullParameters_MacCountByLoc

	ffj_t_FullParameters_UniqueLocs

	ffj_t_FullParameters_UniqueMacs

	ffj_t_FullParameters_Priors

	ffj_t_FullParameters_Results

	ffj_t_FullParameters_Loaded
)

var ffj_key_FullParameters_NetworkMacs = []byte("NetworkMacs")

var ffj_key_FullParameters_NetworkLocs = []byte("NetworkLocs")

var ffj_key_FullParameters_MacVariability = []byte("MacVariability")

var ffj_key_FullParameters_MacCount = []byte("MacCount")

var ffj_key_FullParameters_MacCountByLoc = []byte("MacCountByLoc")

var ffj_key_FullParameters_UniqueLocs = []byte("UniqueLocs")

var ffj_key_FullParameters_UniqueMacs = []byte("UniqueMacs")

var ffj_key_FullParameters_Priors = []byte("Priors")

var ffj_key_FullParameters_Results = []byte("Results")

var ffj_key_FullParameters_Loaded = []byte("Loaded")

func (uj *FullParameters) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *FullParameters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_FullParametersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_FullParametersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'L':

					if bytes.Equal(ffj_key_FullParameters_Loaded, kn) {
						currentKey = ffj_t_FullParameters_Loaded
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'M':

					if bytes.Equal(ffj_key_FullParameters_MacVariability, kn) {
						currentKey = ffj_t_FullParameters_MacVariability
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_FullParameters_MacCount, kn) {
						currentKey = ffj_t_FullParameters_MacCount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_FullParameters_MacCountByLoc, kn) {
						currentKey = ffj_t_FullParameters_MacCountByLoc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'N':

					if bytes.Equal(ffj_key_FullParameters_NetworkMacs, kn) {
						currentKey = ffj_t_FullParameters_NetworkMacs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_FullParameters_NetworkLocs, kn) {
						currentKey = ffj_t_FullParameters_NetworkLocs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffj_key_FullParameters_Priors, kn) {
						currentKey = ffj_t_FullParameters_Priors
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'R':

					if bytes.Equal(ffj_key_FullParameters_Results, kn) {
						currentKey = ffj_t_FullParameters_Results
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'U':

					if bytes.Equal(ffj_key_FullParameters_UniqueLocs, kn) {
						currentKey = ffj_t_FullParameters_UniqueLocs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_FullParameters_UniqueMacs, kn) {
						currentKey = ffj_t_FullParameters_UniqueMacs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_FullParameters_Loaded, kn) {
					currentKey = ffj_t_FullParameters_Loaded
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_FullParameters_Results, kn) {
					currentKey = ffj_t_FullParameters_Results
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_FullParameters_Priors, kn) {
					currentKey = ffj_t_FullParameters_Priors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_FullParameters_UniqueMacs, kn) {
					currentKey = ffj_t_FullParameters_UniqueMacs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_FullParameters_UniqueLocs, kn) {
					currentKey = ffj_t_FullParameters_UniqueLocs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_FullParameters_MacCountByLoc, kn) {
					currentKey = ffj_t_FullParameters_MacCountByLoc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_FullParameters_MacCount, kn) {
					currentKey = ffj_t_FullParameters_MacCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_FullParameters_MacVariability, kn) {
					currentKey = ffj_t_FullParameters_MacVariability
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_FullParameters_NetworkLocs, kn) {
					currentKey = ffj_t_FullParameters_NetworkLocs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_FullParameters_NetworkMacs, kn) {
					currentKey = ffj_t_FullParameters_NetworkMacs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_FullParametersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_FullParameters_NetworkMacs:
					goto handle_NetworkMacs

				case ffj_t_FullParameters_NetworkLocs:
					goto handle_NetworkLocs

				case ffj_t_FullParameters_MacVariability:
					goto handle_MacVariability

				case ffj_t_FullParameters_MacCount:
					goto handle_MacCount

				case ffj_t_FullParameters_MacCountByLoc:
					goto handle_MacCountByLoc

				case ffj_t_FullParameters_UniqueLocs:
					goto handle_UniqueLocs

				case ffj_t_FullParameters_UniqueMacs:
					goto handle_UniqueMacs

				case ffj_t_FullParameters_Priors:
					goto handle_Priors

				case ffj_t_FullParameters_Results:
					goto handle_Results

				case ffj_t_FullParameters_Loaded:
					goto handle_Loaded

				case ffj_t_FullParametersno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_NetworkMacs:

	/* handler: uj.NetworkMacs type=map[string]map[string]bool kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.NetworkMacs = nil
		} else {

			uj.NetworkMacs = make(map[string]map[string]bool, 0)

			wantVal := true

			for {

				var k string

				var tmp_uj__NetworkMacs map[string]bool

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmp_uj__NetworkMacs type=map[string]bool kind=map quoted=false*/

				{

					{
						if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
						}
					}

					if tok == fflib.FFTok_null {
						tmp_uj__NetworkMacs = nil
					} else {

						tmp_uj__NetworkMacs = make(map[string]bool, 0)

						wantVal := true

						for {

							var k string

							var tmp_tmp_uj__NetworkMacs bool

							tok = fs.Scan()
							if tok == fflib.FFTok_error {
								goto tokerror
							}
							if tok == fflib.FFTok_right_bracket {
								break
							}

							if tok == fflib.FFTok_comma {
								if wantVal == true {
									// TODO(pquerna): this isn't an ideal error message, this handles
									// things like [,,,] as an array value.
									return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
								}
								continue
							} else {
								wantVal = true
							}

							/* handler: k type=string kind=string quoted=false*/

							{

								{
									if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
										return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
									}
								}

								if tok == fflib.FFTok_null {

								} else {

									outBuf := fs.Output.Bytes()

									k = string(string(outBuf))

								}
							}

							// Expect ':' after key
							tok = fs.Scan()
							if tok != fflib.FFTok_colon {
								return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
							}

							tok = fs.Scan()
							/* handler: tmp_tmp_uj__NetworkMacs type=bool kind=bool quoted=false*/

							{
								if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
									return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
								}
							}

							{
								if tok == fflib.FFTok_null {

								} else {
									tmpb := fs.Output.Bytes()

									if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

										tmp_tmp_uj__NetworkMacs = true

									} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

										tmp_tmp_uj__NetworkMacs = false

									} else {
										err = errors.New("unexpected bytes for true/false value")
										return fs.WrapErr(err)
									}

								}
							}

							tmp_uj__NetworkMacs[k] = tmp_tmp_uj__NetworkMacs

							wantVal = false
						}

					}
				}

				uj.NetworkMacs[k] = tmp_uj__NetworkMacs

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetworkLocs:

	/* handler: uj.NetworkLocs type=map[string]map[string]bool kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.NetworkLocs = nil
		} else {

			uj.NetworkLocs = make(map[string]map[string]bool, 0)

			wantVal := true

			for {

				var k string

				var tmp_uj__NetworkLocs map[string]bool

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmp_uj__NetworkLocs type=map[string]bool kind=map quoted=false*/

				{

					{
						if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
						}
					}

					if tok == fflib.FFTok_null {
						tmp_uj__NetworkLocs = nil
					} else {

						tmp_uj__NetworkLocs = make(map[string]bool, 0)

						wantVal := true

						for {

							var k string

							var tmp_tmp_uj__NetworkLocs bool

							tok = fs.Scan()
							if tok == fflib.FFTok_error {
								goto tokerror
							}
							if tok == fflib.FFTok_right_bracket {
								break
							}

							if tok == fflib.FFTok_comma {
								if wantVal == true {
									// TODO(pquerna): this isn't an ideal error message, this handles
									// things like [,,,] as an array value.
									return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
								}
								continue
							} else {
								wantVal = true
							}

							/* handler: k type=string kind=string quoted=false*/

							{

								{
									if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
										return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
									}
								}

								if tok == fflib.FFTok_null {

								} else {

									outBuf := fs.Output.Bytes()

									k = string(string(outBuf))

								}
							}

							// Expect ':' after key
							tok = fs.Scan()
							if tok != fflib.FFTok_colon {
								return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
							}

							tok = fs.Scan()
							/* handler: tmp_tmp_uj__NetworkLocs type=bool kind=bool quoted=false*/

							{
								if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
									return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
								}
							}

							{
								if tok == fflib.FFTok_null {

								} else {
									tmpb := fs.Output.Bytes()

									if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

										tmp_tmp_uj__NetworkLocs = true

									} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

										tmp_tmp_uj__NetworkLocs = false

									} else {
										err = errors.New("unexpected bytes for true/false value")
										return fs.WrapErr(err)
									}

								}
							}

							tmp_uj__NetworkLocs[k] = tmp_tmp_uj__NetworkLocs

							wantVal = false
						}

					}
				}

				uj.NetworkLocs[k] = tmp_uj__NetworkLocs

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MacVariability:

	/* handler: uj.MacVariability type=map[string]float32 kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.MacVariability = nil
		} else {

			uj.MacVariability = make(map[string]float32, 0)

			wantVal := true

			for {

				var k string

				var tmp_uj__MacVariability float32

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmp_uj__MacVariability type=float32 kind=float32 quoted=false*/

				{
					if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmp_uj__MacVariability = float32(tval)

					}
				}

				uj.MacVariability[k] = tmp_uj__MacVariability

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MacCount:

	/* handler: uj.MacCount type=map[string]int kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.MacCount = nil
		} else {

			uj.MacCount = make(map[string]int, 0)

			wantVal := true

			for {

				var k string

				var tmp_uj__MacCount int

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmp_uj__MacCount type=int kind=int quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmp_uj__MacCount = int(tval)

					}
				}

				uj.MacCount[k] = tmp_uj__MacCount

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MacCountByLoc:

	/* handler: uj.MacCountByLoc type=map[string]map[string]int kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.MacCountByLoc = nil
		} else {

			uj.MacCountByLoc = make(map[string]map[string]int, 0)

			wantVal := true

			for {

				var k string

				var tmp_uj__MacCountByLoc map[string]int

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmp_uj__MacCountByLoc type=map[string]int kind=map quoted=false*/

				{

					{
						if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
						}
					}

					if tok == fflib.FFTok_null {
						tmp_uj__MacCountByLoc = nil
					} else {

						tmp_uj__MacCountByLoc = make(map[string]int, 0)

						wantVal := true

						for {

							var k string

							var tmp_tmp_uj__MacCountByLoc int

							tok = fs.Scan()
							if tok == fflib.FFTok_error {
								goto tokerror
							}
							if tok == fflib.FFTok_right_bracket {
								break
							}

							if tok == fflib.FFTok_comma {
								if wantVal == true {
									// TODO(pquerna): this isn't an ideal error message, this handles
									// things like [,,,] as an array value.
									return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
								}
								continue
							} else {
								wantVal = true
							}

							/* handler: k type=string kind=string quoted=false*/

							{

								{
									if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
										return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
									}
								}

								if tok == fflib.FFTok_null {

								} else {

									outBuf := fs.Output.Bytes()

									k = string(string(outBuf))

								}
							}

							// Expect ':' after key
							tok = fs.Scan()
							if tok != fflib.FFTok_colon {
								return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
							}

							tok = fs.Scan()
							/* handler: tmp_tmp_uj__MacCountByLoc type=int kind=int quoted=false*/

							{
								if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
									return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
								}
							}

							{

								if tok == fflib.FFTok_null {

								} else {

									tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

									if err != nil {
										return fs.WrapErr(err)
									}

									tmp_tmp_uj__MacCountByLoc = int(tval)

								}
							}

							tmp_uj__MacCountByLoc[k] = tmp_tmp_uj__MacCountByLoc

							wantVal = false
						}

					}
				}

				uj.MacCountByLoc[k] = tmp_uj__MacCountByLoc

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UniqueLocs:

	/* handler: uj.UniqueLocs type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.UniqueLocs = nil
		} else {

			uj.UniqueLocs = make([]string, 0)

			wantVal := true

			for {

				var tmp_uj__UniqueLocs string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__UniqueLocs type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__UniqueLocs = string(string(outBuf))

					}
				}

				uj.UniqueLocs = append(uj.UniqueLocs, tmp_uj__UniqueLocs)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UniqueMacs:

	/* handler: uj.UniqueMacs type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.UniqueMacs = nil
		} else {

			uj.UniqueMacs = make([]string, 0)

			wantVal := true

			for {

				var tmp_uj__UniqueMacs string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__UniqueMacs type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__UniqueMacs = string(string(outBuf))

					}
				}

				uj.UniqueMacs = append(uj.UniqueMacs, tmp_uj__UniqueMacs)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Priors:

	/* handler: uj.Priors type=map[string]gofind.PriorParameters kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Priors = nil
		} else {

			uj.Priors = make(map[string]PriorParameters, 0)

			wantVal := true

			for {

				var k string

				var tmp_uj__Priors PriorParameters

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmp_uj__Priors type=gofind.PriorParameters kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__Priors.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Priors[k] = tmp_uj__Priors

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Results:

	/* handler: uj.Results type=map[string]gofind.ResultsParameters kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Results = nil
		} else {

			uj.Results = make(map[string]ResultsParameters, 0)

			wantVal := true

			for {

				var k string

				var tmp_uj__Results ResultsParameters

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmp_uj__Results type=gofind.ResultsParameters kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__Results.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Results[k] = tmp_uj__Results

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Loaded:

	/* handler: uj.Loaded type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Loaded = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Loaded = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PriorParameters) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PriorParameters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"P":`)
	/* Falling back. type=map[string]map[string][]float32 kind=map */
	err = buf.Encode(mj.P)
	if err != nil {
		return err
	}
	buf.WriteString(`,"NP":`)
	/* Falling back. type=map[string]map[string][]float32 kind=map */
	err = buf.Encode(mj.NP)
	if err != nil {
		return err
	}
	buf.WriteString(`,"MacFreq":`)
	/* Falling back. type=map[string]map[string]float32 kind=map */
	err = buf.Encode(mj.MacFreq)
	if err != nil {
		return err
	}
	buf.WriteString(`,"NMacFreq":`)
	/* Falling back. type=map[string]map[string]float32 kind=map */
	err = buf.Encode(mj.NMacFreq)
	if err != nil {
		return err
	}
	if mj.Special == nil {
		buf.WriteString(`,"Special":null`)
	} else {
		buf.WriteString(`,"Special":{ `)
		for key, value := range mj.Special {
			fflib.WriteJsonString(buf, key)
			buf.WriteString(`:`)
			fflib.AppendFloat(buf, float64(value), 'g', -1, 64)
			buf.WriteByte(',')
		}
		buf.Rewind(1)
		buf.WriteByte('}')
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PriorParametersbase = iota
	ffj_t_PriorParametersno_such_key

	ffj_t_PriorParameters_P

	ffj_t_PriorParameters_NP

	ffj_t_PriorParameters_MacFreq

	ffj_t_PriorParameters_NMacFreq

	ffj_t_PriorParameters_Special
)

var ffj_key_PriorParameters_P = []byte("P")

var ffj_key_PriorParameters_NP = []byte("NP")

var ffj_key_PriorParameters_MacFreq = []byte("MacFreq")

var ffj_key_PriorParameters_NMacFreq = []byte("NMacFreq")

var ffj_key_PriorParameters_Special = []byte("Special")

func (uj *PriorParameters) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PriorParameters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PriorParametersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PriorParametersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'M':

					if bytes.Equal(ffj_key_PriorParameters_MacFreq, kn) {
						currentKey = ffj_t_PriorParameters_MacFreq
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'N':

					if bytes.Equal(ffj_key_PriorParameters_NP, kn) {
						currentKey = ffj_t_PriorParameters_NP
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PriorParameters_NMacFreq, kn) {
						currentKey = ffj_t_PriorParameters_NMacFreq
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffj_key_PriorParameters_P, kn) {
						currentKey = ffj_t_PriorParameters_P
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffj_key_PriorParameters_Special, kn) {
						currentKey = ffj_t_PriorParameters_Special
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PriorParameters_Special, kn) {
					currentKey = ffj_t_PriorParameters_Special
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PriorParameters_NMacFreq, kn) {
					currentKey = ffj_t_PriorParameters_NMacFreq
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PriorParameters_MacFreq, kn) {
					currentKey = ffj_t_PriorParameters_MacFreq
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PriorParameters_NP, kn) {
					currentKey = ffj_t_PriorParameters_NP
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PriorParameters_P, kn) {
					currentKey = ffj_t_PriorParameters_P
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PriorParametersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PriorParameters_P:
					goto handle_P

				case ffj_t_PriorParameters_NP:
					goto handle_NP

				case ffj_t_PriorParameters_MacFreq:
					goto handle_MacFreq

				case ffj_t_PriorParameters_NMacFreq:
					goto handle_NMacFreq

				case ffj_t_PriorParameters_Special:
					goto handle_Special

				case ffj_t_PriorParametersno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_P:

	/* handler: uj.P type=map[string]map[string][]float32 kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.P = nil
		} else {

			uj.P = make(map[string]map[string][]float32, 0)

			wantVal := true

			for {

				var k string

				var tmp_uj__P map[string][]float32

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmp_uj__P type=map[string][]float32 kind=map quoted=false*/

				{

					{
						if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
						}
					}

					if tok == fflib.FFTok_null {
						tmp_uj__P = nil
					} else {

						tmp_uj__P = make(map[string][]float32, 0)

						wantVal := true

						for {

							var k string

							var tmp_tmp_uj__P []float32

							tok = fs.Scan()
							if tok == fflib.FFTok_error {
								goto tokerror
							}
							if tok == fflib.FFTok_right_bracket {
								break
							}

							if tok == fflib.FFTok_comma {
								if wantVal == true {
									// TODO(pquerna): this isn't an ideal error message, this handles
									// things like [,,,] as an array value.
									return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
								}
								continue
							} else {
								wantVal = true
							}

							/* handler: k type=string kind=string quoted=false*/

							{

								{
									if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
										return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
									}
								}

								if tok == fflib.FFTok_null {

								} else {

									outBuf := fs.Output.Bytes()

									k = string(string(outBuf))

								}
							}

							// Expect ':' after key
							tok = fs.Scan()
							if tok != fflib.FFTok_colon {
								return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
							}

							tok = fs.Scan()
							/* handler: tmp_tmp_uj__P type=[]float32 kind=slice quoted=false*/

							{

								{
									if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
										return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
									}
								}

								if tok == fflib.FFTok_null {
									tmp_tmp_uj__P = nil
								} else {

									tmp_tmp_uj__P = make([]float32, 0)

									wantVal := true

									for {

										var tmp_tmp_tmp_uj__P float32

										tok = fs.Scan()
										if tok == fflib.FFTok_error {
											goto tokerror
										}
										if tok == fflib.FFTok_right_brace {
											break
										}

										if tok == fflib.FFTok_comma {
											if wantVal == true {
												// TODO(pquerna): this isn't an ideal error message, this handles
												// things like [,,,] as an array value.
												return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
											}
											continue
										} else {
											wantVal = true
										}

										/* handler: tmp_tmp_tmp_uj__P type=float32 kind=float32 quoted=false*/

										{
											if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
												return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
											}
										}

										{

											if tok == fflib.FFTok_null {

											} else {

												tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

												if err != nil {
													return fs.WrapErr(err)
												}

												tmp_tmp_tmp_uj__P = float32(tval)

											}
										}

										tmp_tmp_uj__P = append(tmp_tmp_uj__P, tmp_tmp_tmp_uj__P)
										wantVal = false
									}
								}
							}

							tmp_uj__P[k] = tmp_tmp_uj__P

							wantVal = false
						}

					}
				}

				uj.P[k] = tmp_uj__P

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NP:

	/* handler: uj.NP type=map[string]map[string][]float32 kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.NP = nil
		} else {

			uj.NP = make(map[string]map[string][]float32, 0)

			wantVal := true

			for {

				var k string

				var tmp_uj__NP map[string][]float32

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmp_uj__NP type=map[string][]float32 kind=map quoted=false*/

				{

					{
						if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
						}
					}

					if tok == fflib.FFTok_null {
						tmp_uj__NP = nil
					} else {

						tmp_uj__NP = make(map[string][]float32, 0)

						wantVal := true

						for {

							var k string

							var tmp_tmp_uj__NP []float32

							tok = fs.Scan()
							if tok == fflib.FFTok_error {
								goto tokerror
							}
							if tok == fflib.FFTok_right_bracket {
								break
							}

							if tok == fflib.FFTok_comma {
								if wantVal == true {
									// TODO(pquerna): this isn't an ideal error message, this handles
									// things like [,,,] as an array value.
									return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
								}
								continue
							} else {
								wantVal = true
							}

							/* handler: k type=string kind=string quoted=false*/

							{

								{
									if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
										return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
									}
								}

								if tok == fflib.FFTok_null {

								} else {

									outBuf := fs.Output.Bytes()

									k = string(string(outBuf))

								}
							}

							// Expect ':' after key
							tok = fs.Scan()
							if tok != fflib.FFTok_colon {
								return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
							}

							tok = fs.Scan()
							/* handler: tmp_tmp_uj__NP type=[]float32 kind=slice quoted=false*/

							{

								{
									if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
										return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
									}
								}

								if tok == fflib.FFTok_null {
									tmp_tmp_uj__NP = nil
								} else {

									tmp_tmp_uj__NP = make([]float32, 0)

									wantVal := true

									for {

										var tmp_tmp_tmp_uj__NP float32

										tok = fs.Scan()
										if tok == fflib.FFTok_error {
											goto tokerror
										}
										if tok == fflib.FFTok_right_brace {
											break
										}

										if tok == fflib.FFTok_comma {
											if wantVal == true {
												// TODO(pquerna): this isn't an ideal error message, this handles
												// things like [,,,] as an array value.
												return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
											}
											continue
										} else {
											wantVal = true
										}

										/* handler: tmp_tmp_tmp_uj__NP type=float32 kind=float32 quoted=false*/

										{
											if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
												return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
											}
										}

										{

											if tok == fflib.FFTok_null {

											} else {

												tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

												if err != nil {
													return fs.WrapErr(err)
												}

												tmp_tmp_tmp_uj__NP = float32(tval)

											}
										}

										tmp_tmp_uj__NP = append(tmp_tmp_uj__NP, tmp_tmp_tmp_uj__NP)
										wantVal = false
									}
								}
							}

							tmp_uj__NP[k] = tmp_tmp_uj__NP

							wantVal = false
						}

					}
				}

				uj.NP[k] = tmp_uj__NP

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MacFreq:

	/* handler: uj.MacFreq type=map[string]map[string]float32 kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.MacFreq = nil
		} else {

			uj.MacFreq = make(map[string]map[string]float32, 0)

			wantVal := true

			for {

				var k string

				var tmp_uj__MacFreq map[string]float32

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmp_uj__MacFreq type=map[string]float32 kind=map quoted=false*/

				{

					{
						if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
						}
					}

					if tok == fflib.FFTok_null {
						tmp_uj__MacFreq = nil
					} else {

						tmp_uj__MacFreq = make(map[string]float32, 0)

						wantVal := true

						for {

							var k string

							var tmp_tmp_uj__MacFreq float32

							tok = fs.Scan()
							if tok == fflib.FFTok_error {
								goto tokerror
							}
							if tok == fflib.FFTok_right_bracket {
								break
							}

							if tok == fflib.FFTok_comma {
								if wantVal == true {
									// TODO(pquerna): this isn't an ideal error message, this handles
									// things like [,,,] as an array value.
									return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
								}
								continue
							} else {
								wantVal = true
							}

							/* handler: k type=string kind=string quoted=false*/

							{

								{
									if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
										return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
									}
								}

								if tok == fflib.FFTok_null {

								} else {

									outBuf := fs.Output.Bytes()

									k = string(string(outBuf))

								}
							}

							// Expect ':' after key
							tok = fs.Scan()
							if tok != fflib.FFTok_colon {
								return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
							}

							tok = fs.Scan()
							/* handler: tmp_tmp_uj__MacFreq type=float32 kind=float32 quoted=false*/

							{
								if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
									return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
								}
							}

							{

								if tok == fflib.FFTok_null {

								} else {

									tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

									if err != nil {
										return fs.WrapErr(err)
									}

									tmp_tmp_uj__MacFreq = float32(tval)

								}
							}

							tmp_uj__MacFreq[k] = tmp_tmp_uj__MacFreq

							wantVal = false
						}

					}
				}

				uj.MacFreq[k] = tmp_uj__MacFreq

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NMacFreq:

	/* handler: uj.NMacFreq type=map[string]map[string]float32 kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.NMacFreq = nil
		} else {

			uj.NMacFreq = make(map[string]map[string]float32, 0)

			wantVal := true

			for {

				var k string

				var tmp_uj__NMacFreq map[string]float32

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmp_uj__NMacFreq type=map[string]float32 kind=map quoted=false*/

				{

					{
						if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
						}
					}

					if tok == fflib.FFTok_null {
						tmp_uj__NMacFreq = nil
					} else {

						tmp_uj__NMacFreq = make(map[string]float32, 0)

						wantVal := true

						for {

							var k string

							var tmp_tmp_uj__NMacFreq float32

							tok = fs.Scan()
							if tok == fflib.FFTok_error {
								goto tokerror
							}
							if tok == fflib.FFTok_right_bracket {
								break
							}

							if tok == fflib.FFTok_comma {
								if wantVal == true {
									// TODO(pquerna): this isn't an ideal error message, this handles
									// things like [,,,] as an array value.
									return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
								}
								continue
							} else {
								wantVal = true
							}

							/* handler: k type=string kind=string quoted=false*/

							{

								{
									if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
										return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
									}
								}

								if tok == fflib.FFTok_null {

								} else {

									outBuf := fs.Output.Bytes()

									k = string(string(outBuf))

								}
							}

							// Expect ':' after key
							tok = fs.Scan()
							if tok != fflib.FFTok_colon {
								return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
							}

							tok = fs.Scan()
							/* handler: tmp_tmp_uj__NMacFreq type=float32 kind=float32 quoted=false*/

							{
								if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
									return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
								}
							}

							{

								if tok == fflib.FFTok_null {

								} else {

									tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

									if err != nil {
										return fs.WrapErr(err)
									}

									tmp_tmp_uj__NMacFreq = float32(tval)

								}
							}

							tmp_uj__NMacFreq[k] = tmp_tmp_uj__NMacFreq

							wantVal = false
						}

					}
				}

				uj.NMacFreq[k] = tmp_uj__NMacFreq

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Special:

	/* handler: uj.Special type=map[string]float64 kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Special = nil
		} else {

			uj.Special = make(map[string]float64, 0)

			wantVal := true

			for {

				var k string

				var tmp_uj__Special float64

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmp_uj__Special type=float64 kind=float64 quoted=false*/

				{
					if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmp_uj__Special = float64(tval)

					}
				}

				uj.Special[k] = tmp_uj__Special

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ResultsParameters) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ResultsParameters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if mj.Accuracy == nil {
		buf.WriteString(`{"Accuracy":null`)
	} else {
		buf.WriteString(`{"Accuracy":{ `)
		for key, value := range mj.Accuracy {
			fflib.WriteJsonString(buf, key)
			buf.WriteString(`:`)
			fflib.FormatBits2(buf, uint64(value), 10, value < 0)
			buf.WriteByte(',')
		}
		buf.Rewind(1)
		buf.WriteByte('}')
	}
	if mj.TotalLocations == nil {
		buf.WriteString(`,"TotalLocations":null`)
	} else {
		buf.WriteString(`,"TotalLocations":{ `)
		for key, value := range mj.TotalLocations {
			fflib.WriteJsonString(buf, key)
			buf.WriteString(`:`)
			fflib.FormatBits2(buf, uint64(value), 10, value < 0)
			buf.WriteByte(',')
		}
		buf.Rewind(1)
		buf.WriteByte('}')
	}
	if mj.CorrectLocations == nil {
		buf.WriteString(`,"CorrectLocations":null`)
	} else {
		buf.WriteString(`,"CorrectLocations":{ `)
		for key, value := range mj.CorrectLocations {
			fflib.WriteJsonString(buf, key)
			buf.WriteString(`:`)
			fflib.FormatBits2(buf, uint64(value), 10, value < 0)
			buf.WriteByte(',')
		}
		buf.Rewind(1)
		buf.WriteByte('}')
	}
	buf.WriteString(`,"Guess":`)
	/* Falling back. type=map[string]map[string]int kind=map */
	err = buf.Encode(mj.Guess)
	if err != nil {
		return err
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ResultsParametersbase = iota
	ffj_t_ResultsParametersno_such_key

	ffj_t_ResultsParameters_Accuracy

	ffj_t_ResultsParameters_TotalLocations

	ffj_t_ResultsParameters_CorrectLocations

	ffj_t_ResultsParameters_Guess
)

var ffj_key_ResultsParameters_Accuracy = []byte("Accuracy")

var ffj_key_ResultsParameters_TotalLocations = []byte("TotalLocations")

var ffj_key_ResultsParameters_CorrectLocations = []byte("CorrectLocations")

var ffj_key_ResultsParameters_Guess = []byte("Guess")

func (uj *ResultsParameters) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ResultsParameters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ResultsParametersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ResultsParametersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'A':

					if bytes.Equal(ffj_key_ResultsParameters_Accuracy, kn) {
						currentKey = ffj_t_ResultsParameters_Accuracy
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'C':

					if bytes.Equal(ffj_key_ResultsParameters_CorrectLocations, kn) {
						currentKey = ffj_t_ResultsParameters_CorrectLocations
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'G':

					if bytes.Equal(ffj_key_ResultsParameters_Guess, kn) {
						currentKey = ffj_t_ResultsParameters_Guess
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'T':

					if bytes.Equal(ffj_key_ResultsParameters_TotalLocations, kn) {
						currentKey = ffj_t_ResultsParameters_TotalLocations
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ResultsParameters_Guess, kn) {
					currentKey = ffj_t_ResultsParameters_Guess
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResultsParameters_CorrectLocations, kn) {
					currentKey = ffj_t_ResultsParameters_CorrectLocations
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResultsParameters_TotalLocations, kn) {
					currentKey = ffj_t_ResultsParameters_TotalLocations
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ResultsParameters_Accuracy, kn) {
					currentKey = ffj_t_ResultsParameters_Accuracy
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ResultsParametersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ResultsParameters_Accuracy:
					goto handle_Accuracy

				case ffj_t_ResultsParameters_TotalLocations:
					goto handle_TotalLocations

				case ffj_t_ResultsParameters_CorrectLocations:
					goto handle_CorrectLocations

				case ffj_t_ResultsParameters_Guess:
					goto handle_Guess

				case ffj_t_ResultsParametersno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Accuracy:

	/* handler: uj.Accuracy type=map[string]int kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Accuracy = nil
		} else {

			uj.Accuracy = make(map[string]int, 0)

			wantVal := true

			for {

				var k string

				var tmp_uj__Accuracy int

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmp_uj__Accuracy type=int kind=int quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmp_uj__Accuracy = int(tval)

					}
				}

				uj.Accuracy[k] = tmp_uj__Accuracy

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalLocations:

	/* handler: uj.TotalLocations type=map[string]int kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.TotalLocations = nil
		} else {

			uj.TotalLocations = make(map[string]int, 0)

			wantVal := true

			for {

				var k string

				var tmp_uj__TotalLocations int

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmp_uj__TotalLocations type=int kind=int quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmp_uj__TotalLocations = int(tval)

					}
				}

				uj.TotalLocations[k] = tmp_uj__TotalLocations

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CorrectLocations:

	/* handler: uj.CorrectLocations type=map[string]int kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.CorrectLocations = nil
		} else {

			uj.CorrectLocations = make(map[string]int, 0)

			wantVal := true

			for {

				var k string

				var tmp_uj__CorrectLocations int

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmp_uj__CorrectLocations type=int kind=int quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmp_uj__CorrectLocations = int(tval)

					}
				}

				uj.CorrectLocations[k] = tmp_uj__CorrectLocations

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Guess:

	/* handler: uj.Guess type=map[string]map[string]int kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Guess = nil
		} else {

			uj.Guess = make(map[string]map[string]int, 0)

			wantVal := true

			for {

				var k string

				var tmp_uj__Guess map[string]int

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmp_uj__Guess type=map[string]int kind=map quoted=false*/

				{

					{
						if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
						}
					}

					if tok == fflib.FFTok_null {
						tmp_uj__Guess = nil
					} else {

						tmp_uj__Guess = make(map[string]int, 0)

						wantVal := true

						for {

							var k string

							var tmp_tmp_uj__Guess int

							tok = fs.Scan()
							if tok == fflib.FFTok_error {
								goto tokerror
							}
							if tok == fflib.FFTok_right_bracket {
								break
							}

							if tok == fflib.FFTok_comma {
								if wantVal == true {
									// TODO(pquerna): this isn't an ideal error message, this handles
									// things like [,,,] as an array value.
									return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
								}
								continue
							} else {
								wantVal = true
							}

							/* handler: k type=string kind=string quoted=false*/

							{

								{
									if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
										return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
									}
								}

								if tok == fflib.FFTok_null {

								} else {

									outBuf := fs.Output.Bytes()

									k = string(string(outBuf))

								}
							}

							// Expect ':' after key
							tok = fs.Scan()
							if tok != fflib.FFTok_colon {
								return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
							}

							tok = fs.Scan()
							/* handler: tmp_tmp_uj__Guess type=int kind=int quoted=false*/

							{
								if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
									return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
								}
							}

							{

								if tok == fflib.FFTok_null {

								} else {

									tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

									if err != nil {
										return fs.WrapErr(err)
									}

									tmp_tmp_uj__Guess = int(tval)

								}
							}

							tmp_uj__Guess[k] = tmp_tmp_uj__Guess

							wantVal = false
						}

					}
				}

				uj.Guess[k] = tmp_uj__Guess

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}
