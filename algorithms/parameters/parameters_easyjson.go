// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package parameters

import (
	json "encoding/json"
	easyjson "github.com/mailru/easyjson"
	jlexer "github.com/mailru/easyjson/jlexer"
	jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
	_ *json.RawMessage
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ easyjson.Marshaler
)

func easyjson224c90e0DecodeParsinServerAlgorithmsParameters(in *jlexer.Lexer, out *ResultsParameters) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "Accuracy":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				if !in.IsDelim('}') {
					out.Accuracy = make(map[string]int)
				} else {
					out.Accuracy = nil
				}
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v1 int
					v1 = int(in.Int())
					(out.Accuracy)[key] = v1
					in.WantComma()
				}
				in.Delim('}')
			}
		case "TotalLocations":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				if !in.IsDelim('}') {
					out.TotalLocations = make(map[string]int)
				} else {
					out.TotalLocations = nil
				}
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v2 int
					v2 = int(in.Int())
					(out.TotalLocations)[key] = v2
					in.WantComma()
				}
				in.Delim('}')
			}
		case "CorrectLocations":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				if !in.IsDelim('}') {
					out.CorrectLocations = make(map[string]int)
				} else {
					out.CorrectLocations = nil
				}
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v3 int
					v3 = int(in.Int())
					(out.CorrectLocations)[key] = v3
					in.WantComma()
				}
				in.Delim('}')
			}
		case "Guess":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				if !in.IsDelim('}') {
					out.Guess = make(map[string]map[string]int)
				} else {
					out.Guess = nil
				}
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v4 map[string]int
					if in.IsNull() {
						in.Skip()
					} else {
						in.Delim('{')
						if !in.IsDelim('}') {
							v4 = make(map[string]int)
						} else {
							v4 = nil
						}
						for !in.IsDelim('}') {
							key := string(in.String())
							in.WantColon()
							var v5 int
							v5 = int(in.Int())
							(v4)[key] = v5
							in.WantComma()
						}
						in.Delim('}')
					}
					(out.Guess)[key] = v4
					in.WantComma()
				}
				in.Delim('}')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson224c90e0EncodeParsinServerAlgorithmsParameters(out *jwriter.Writer, in ResultsParameters) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"Accuracy\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Accuracy == nil && (out.Flags&jwriter.NilMapAsEmpty) == 0 {
			out.RawString(`null`)
		} else {
			out.RawByte('{')
			v6First := true
			for v6Name, v6Value := range in.Accuracy {
				if v6First {
					v6First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v6Name))
				out.RawByte(':')
				out.Int(int(v6Value))
			}
			out.RawByte('}')
		}
	}
	{
		const prefix string = ",\"TotalLocations\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.TotalLocations == nil && (out.Flags&jwriter.NilMapAsEmpty) == 0 {
			out.RawString(`null`)
		} else {
			out.RawByte('{')
			v7First := true
			for v7Name, v7Value := range in.TotalLocations {
				if v7First {
					v7First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v7Name))
				out.RawByte(':')
				out.Int(int(v7Value))
			}
			out.RawByte('}')
		}
	}
	{
		const prefix string = ",\"CorrectLocations\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.CorrectLocations == nil && (out.Flags&jwriter.NilMapAsEmpty) == 0 {
			out.RawString(`null`)
		} else {
			out.RawByte('{')
			v8First := true
			for v8Name, v8Value := range in.CorrectLocations {
				if v8First {
					v8First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v8Name))
				out.RawByte(':')
				out.Int(int(v8Value))
			}
			out.RawByte('}')
		}
	}
	{
		const prefix string = ",\"Guess\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Guess == nil && (out.Flags&jwriter.NilMapAsEmpty) == 0 {
			out.RawString(`null`)
		} else {
			out.RawByte('{')
			v9First := true
			for v9Name, v9Value := range in.Guess {
				if v9First {
					v9First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v9Name))
				out.RawByte(':')
				if v9Value == nil && (out.Flags&jwriter.NilMapAsEmpty) == 0 {
					out.RawString(`null`)
				} else {
					out.RawByte('{')
					v10First := true
					for v10Name, v10Value := range v9Value {
						if v10First {
							v10First = false
						} else {
							out.RawByte(',')
						}
						out.String(string(v10Name))
						out.RawByte(':')
						out.Int(int(v10Value))
					}
					out.RawByte('}')
				}
			}
			out.RawByte('}')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v ResultsParameters) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson224c90e0EncodeParsinServerAlgorithmsParameters(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v ResultsParameters) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson224c90e0EncodeParsinServerAlgorithmsParameters(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *ResultsParameters) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson224c90e0DecodeParsinServerAlgorithmsParameters(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *ResultsParameters) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson224c90e0DecodeParsinServerAlgorithmsParameters(l, v)
}
func easyjson224c90e0DecodeParsinServerAlgorithmsParameters1(in *jlexer.Lexer, out *PriorParameters) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "P":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				if !in.IsDelim('}') {
					out.P = make(map[string]map[string][]float32)
				} else {
					out.P = nil
				}
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v11 map[string][]float32
					if in.IsNull() {
						in.Skip()
					} else {
						in.Delim('{')
						if !in.IsDelim('}') {
							v11 = make(map[string][]float32)
						} else {
							v11 = nil
						}
						for !in.IsDelim('}') {
							key := string(in.String())
							in.WantColon()
							var v12 []float32
							if in.IsNull() {
								in.Skip()
								v12 = nil
							} else {
								in.Delim('[')
								if v12 == nil {
									if !in.IsDelim(']') {
										v12 = make([]float32, 0, 16)
									} else {
										v12 = []float32{}
									}
								} else {
									v12 = (v12)[:0]
								}
								for !in.IsDelim(']') {
									var v13 float32
									v13 = float32(in.Float32())
									v12 = append(v12, v13)
									in.WantComma()
								}
								in.Delim(']')
							}
							(v11)[key] = v12
							in.WantComma()
						}
						in.Delim('}')
					}
					(out.P)[key] = v11
					in.WantComma()
				}
				in.Delim('}')
			}
		case "NP":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				if !in.IsDelim('}') {
					out.NP = make(map[string]map[string][]float32)
				} else {
					out.NP = nil
				}
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v14 map[string][]float32
					if in.IsNull() {
						in.Skip()
					} else {
						in.Delim('{')
						if !in.IsDelim('}') {
							v14 = make(map[string][]float32)
						} else {
							v14 = nil
						}
						for !in.IsDelim('}') {
							key := string(in.String())
							in.WantColon()
							var v15 []float32
							if in.IsNull() {
								in.Skip()
								v15 = nil
							} else {
								in.Delim('[')
								if v15 == nil {
									if !in.IsDelim(']') {
										v15 = make([]float32, 0, 16)
									} else {
										v15 = []float32{}
									}
								} else {
									v15 = (v15)[:0]
								}
								for !in.IsDelim(']') {
									var v16 float32
									v16 = float32(in.Float32())
									v15 = append(v15, v16)
									in.WantComma()
								}
								in.Delim(']')
							}
							(v14)[key] = v15
							in.WantComma()
						}
						in.Delim('}')
					}
					(out.NP)[key] = v14
					in.WantComma()
				}
				in.Delim('}')
			}
		case "MacFreq":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				if !in.IsDelim('}') {
					out.MacFreq = make(map[string]map[string]float32)
				} else {
					out.MacFreq = nil
				}
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v17 map[string]float32
					if in.IsNull() {
						in.Skip()
					} else {
						in.Delim('{')
						if !in.IsDelim('}') {
							v17 = make(map[string]float32)
						} else {
							v17 = nil
						}
						for !in.IsDelim('}') {
							key := string(in.String())
							in.WantColon()
							var v18 float32
							v18 = float32(in.Float32())
							(v17)[key] = v18
							in.WantComma()
						}
						in.Delim('}')
					}
					(out.MacFreq)[key] = v17
					in.WantComma()
				}
				in.Delim('}')
			}
		case "NMacFreq":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				if !in.IsDelim('}') {
					out.NMacFreq = make(map[string]map[string]float32)
				} else {
					out.NMacFreq = nil
				}
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v19 map[string]float32
					if in.IsNull() {
						in.Skip()
					} else {
						in.Delim('{')
						if !in.IsDelim('}') {
							v19 = make(map[string]float32)
						} else {
							v19 = nil
						}
						for !in.IsDelim('}') {
							key := string(in.String())
							in.WantColon()
							var v20 float32
							v20 = float32(in.Float32())
							(v19)[key] = v20
							in.WantComma()
						}
						in.Delim('}')
					}
					(out.NMacFreq)[key] = v19
					in.WantComma()
				}
				in.Delim('}')
			}
		case "Special":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				if !in.IsDelim('}') {
					out.Special = make(map[string]float64)
				} else {
					out.Special = nil
				}
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v21 float64
					v21 = float64(in.Float64())
					(out.Special)[key] = v21
					in.WantComma()
				}
				in.Delim('}')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson224c90e0EncodeParsinServerAlgorithmsParameters1(out *jwriter.Writer, in PriorParameters) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"P\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.P == nil && (out.Flags&jwriter.NilMapAsEmpty) == 0 {
			out.RawString(`null`)
		} else {
			out.RawByte('{')
			v22First := true
			for v22Name, v22Value := range in.P {
				if v22First {
					v22First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v22Name))
				out.RawByte(':')
				if v22Value == nil && (out.Flags&jwriter.NilMapAsEmpty) == 0 {
					out.RawString(`null`)
				} else {
					out.RawByte('{')
					v23First := true
					for v23Name, v23Value := range v22Value {
						if v23First {
							v23First = false
						} else {
							out.RawByte(',')
						}
						out.String(string(v23Name))
						out.RawByte(':')
						if v23Value == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
							out.RawString("null")
						} else {
							out.RawByte('[')
							for v24, v25 := range v23Value {
								if v24 > 0 {
									out.RawByte(',')
								}
								out.Float32(float32(v25))
							}
							out.RawByte(']')
						}
					}
					out.RawByte('}')
				}
			}
			out.RawByte('}')
		}
	}
	{
		const prefix string = ",\"NP\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.NP == nil && (out.Flags&jwriter.NilMapAsEmpty) == 0 {
			out.RawString(`null`)
		} else {
			out.RawByte('{')
			v26First := true
			for v26Name, v26Value := range in.NP {
				if v26First {
					v26First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v26Name))
				out.RawByte(':')
				if v26Value == nil && (out.Flags&jwriter.NilMapAsEmpty) == 0 {
					out.RawString(`null`)
				} else {
					out.RawByte('{')
					v27First := true
					for v27Name, v27Value := range v26Value {
						if v27First {
							v27First = false
						} else {
							out.RawByte(',')
						}
						out.String(string(v27Name))
						out.RawByte(':')
						if v27Value == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
							out.RawString("null")
						} else {
							out.RawByte('[')
							for v28, v29 := range v27Value {
								if v28 > 0 {
									out.RawByte(',')
								}
								out.Float32(float32(v29))
							}
							out.RawByte(']')
						}
					}
					out.RawByte('}')
				}
			}
			out.RawByte('}')
		}
	}
	{
		const prefix string = ",\"MacFreq\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.MacFreq == nil && (out.Flags&jwriter.NilMapAsEmpty) == 0 {
			out.RawString(`null`)
		} else {
			out.RawByte('{')
			v30First := true
			for v30Name, v30Value := range in.MacFreq {
				if v30First {
					v30First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v30Name))
				out.RawByte(':')
				if v30Value == nil && (out.Flags&jwriter.NilMapAsEmpty) == 0 {
					out.RawString(`null`)
				} else {
					out.RawByte('{')
					v31First := true
					for v31Name, v31Value := range v30Value {
						if v31First {
							v31First = false
						} else {
							out.RawByte(',')
						}
						out.String(string(v31Name))
						out.RawByte(':')
						out.Float32(float32(v31Value))
					}
					out.RawByte('}')
				}
			}
			out.RawByte('}')
		}
	}
	{
		const prefix string = ",\"NMacFreq\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.NMacFreq == nil && (out.Flags&jwriter.NilMapAsEmpty) == 0 {
			out.RawString(`null`)
		} else {
			out.RawByte('{')
			v32First := true
			for v32Name, v32Value := range in.NMacFreq {
				if v32First {
					v32First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v32Name))
				out.RawByte(':')
				if v32Value == nil && (out.Flags&jwriter.NilMapAsEmpty) == 0 {
					out.RawString(`null`)
				} else {
					out.RawByte('{')
					v33First := true
					for v33Name, v33Value := range v32Value {
						if v33First {
							v33First = false
						} else {
							out.RawByte(',')
						}
						out.String(string(v33Name))
						out.RawByte(':')
						out.Float32(float32(v33Value))
					}
					out.RawByte('}')
				}
			}
			out.RawByte('}')
		}
	}
	{
		const prefix string = ",\"Special\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Special == nil && (out.Flags&jwriter.NilMapAsEmpty) == 0 {
			out.RawString(`null`)
		} else {
			out.RawByte('{')
			v34First := true
			for v34Name, v34Value := range in.Special {
				if v34First {
					v34First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v34Name))
				out.RawByte(':')
				out.Float64(float64(v34Value))
			}
			out.RawByte('}')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v PriorParameters) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson224c90e0EncodeParsinServerAlgorithmsParameters1(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v PriorParameters) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson224c90e0EncodeParsinServerAlgorithmsParameters1(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *PriorParameters) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson224c90e0DecodeParsinServerAlgorithmsParameters1(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *PriorParameters) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson224c90e0DecodeParsinServerAlgorithmsParameters1(l, v)
}
func easyjson224c90e0DecodeParsinServerAlgorithmsParameters2(in *jlexer.Lexer, out *KnnFingerprints) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "FingerprintsInMemory":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				if !in.IsDelim('}') {
					out.FingerprintsInMemory = make(map[string]Fingerprint)
				} else {
					out.FingerprintsInMemory = nil
				}
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v35 Fingerprint
					(v35).UnmarshalEasyJSON(in)
					(out.FingerprintsInMemory)[key] = v35
					in.WantComma()
				}
				in.Delim('}')
			}
		case "FingerprintsOrdering":
			if in.IsNull() {
				in.Skip()
				out.FingerprintsOrdering = nil
			} else {
				in.Delim('[')
				if out.FingerprintsOrdering == nil {
					if !in.IsDelim(']') {
						out.FingerprintsOrdering = make([]string, 0, 4)
					} else {
						out.FingerprintsOrdering = []string{}
					}
				} else {
					out.FingerprintsOrdering = (out.FingerprintsOrdering)[:0]
				}
				for !in.IsDelim(']') {
					var v36 string
					v36 = string(in.String())
					out.FingerprintsOrdering = append(out.FingerprintsOrdering, v36)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "Clusters":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				if !in.IsDelim('}') {
					out.Clusters = make(map[string][]string)
				} else {
					out.Clusters = nil
				}
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v37 []string
					if in.IsNull() {
						in.Skip()
						v37 = nil
					} else {
						in.Delim('[')
						if v37 == nil {
							if !in.IsDelim(']') {
								v37 = make([]string, 0, 4)
							} else {
								v37 = []string{}
							}
						} else {
							v37 = (v37)[:0]
						}
						for !in.IsDelim(']') {
							var v38 string
							v38 = string(in.String())
							v37 = append(v37, v38)
							in.WantComma()
						}
						in.Delim(']')
					}
					(out.Clusters)[key] = v37
					in.WantComma()
				}
				in.Delim('}')
			}
		case "K":
			out.K = int(in.Int())
		case "MinClusterRss":
			out.MinClusterRss = int(in.Int())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson224c90e0EncodeParsinServerAlgorithmsParameters2(out *jwriter.Writer, in KnnFingerprints) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"FingerprintsInMemory\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.FingerprintsInMemory == nil && (out.Flags&jwriter.NilMapAsEmpty) == 0 {
			out.RawString(`null`)
		} else {
			out.RawByte('{')
			v39First := true
			for v39Name, v39Value := range in.FingerprintsInMemory {
				if v39First {
					v39First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v39Name))
				out.RawByte(':')
				(v39Value).MarshalEasyJSON(out)
			}
			out.RawByte('}')
		}
	}
	{
		const prefix string = ",\"FingerprintsOrdering\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.FingerprintsOrdering == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v40, v41 := range in.FingerprintsOrdering {
				if v40 > 0 {
					out.RawByte(',')
				}
				out.String(string(v41))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"Clusters\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Clusters == nil && (out.Flags&jwriter.NilMapAsEmpty) == 0 {
			out.RawString(`null`)
		} else {
			out.RawByte('{')
			v42First := true
			for v42Name, v42Value := range in.Clusters {
				if v42First {
					v42First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v42Name))
				out.RawByte(':')
				if v42Value == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
					out.RawString("null")
				} else {
					out.RawByte('[')
					for v43, v44 := range v42Value {
						if v43 > 0 {
							out.RawByte(',')
						}
						out.String(string(v44))
					}
					out.RawByte(']')
				}
			}
			out.RawByte('}')
		}
	}
	{
		const prefix string = ",\"K\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int(int(in.K))
	}
	{
		const prefix string = ",\"MinClusterRss\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int(int(in.MinClusterRss))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v KnnFingerprints) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson224c90e0EncodeParsinServerAlgorithmsParameters2(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v KnnFingerprints) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson224c90e0EncodeParsinServerAlgorithmsParameters2(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *KnnFingerprints) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson224c90e0DecodeParsinServerAlgorithmsParameters2(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *KnnFingerprints) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson224c90e0DecodeParsinServerAlgorithmsParameters2(l, v)
}
